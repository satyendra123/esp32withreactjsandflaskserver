// React js code
//Step-1 Components/ Controlled.js
import React from 'react';
import axios from 'axios';
import './Controlled.css';

function Controlled() {
  const handleLedOn = async () => {
    try {
      const response = await axios.get('http://localhost:8000/api/led/on/');
      console.log(response.data);
    } catch (error) {
      console.error("There was an error turning on the LED!", error);
    }
  };

  const handleLedOff = async () => {
    try {
      const response = await axios.get('http://localhost:8000/api/led/off/');
      console.log(response.data);
    } catch (error) {
      console.error("There was an error turning off the LED!", error);
    }
  };

  return (
    <div>
      <h1>ESP32 LED Control</h1>
      <div className="control">
        <button className="btn btn-primary m-2" onClick={handleLedOn}>LED On</button>
        <button className="btn btn-danger m-2" onClick={handleLedOff}>LED Off</button>
      </div>
    </div>
  );
}

export default Controlled;

//Step-2 Components/ Controlled.css


//Step-3 App.js
import './App.css';
import Controlled from './Components/Controlled';
function App() {
  return (
    <div className="App">
      <Controlled/>
    </div>
  );
}

export default App;


//Step-4 App.css
.App {
  text-align: center;
}

// backened/controlled/
views.py
'''
from django.shortcuts import render
from django.http import JsonResponse
from rest_framework.decorators import api_view
from rest_framework import status  # Import status from rest_framework
import requests

ESP32_URL = 'http://<ESP32_IP_ADDRESS>'  # Replace with the actual IP address

@api_view(['GET'])
def led_on_view(request):
    print("Received GET request for LED ON")  # Log the incoming request
    try:
        response = requests.post(f'{ESP32_URL}/led/on')
        if response.status_code == 200:
            return JsonResponse({'status': '|OPENEN%'}, status=status.HTTP_200_OK)
        else:
            return JsonResponse({'status': 'Failed to turn on LED'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    except requests.exceptions.RequestException as e:
        return JsonResponse({'status': 'Failed to connect to ESP32'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def led_off_view(request):
    print("Received GET request for LED OFF")  # Log the incoming request
    try:
        response = requests.post(f'{ESP32_URL}/led/off')
        if response.status_code == 200:
            return JsonResponse({'status': 'C'}, status=status.HTTP_200_OK)
        else:
            return JsonResponse({'status': 'Failed to turn off LED'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    except requests.exceptions.RequestException as e:
        return JsonResponse({'status': 'Failed to connect to ESP32'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
'''
from django.shortcuts import render
from django.http import JsonResponse
from rest_framework.decorators import api_view
from rest_framework import status
import requests

ESP32_URL = 'http://<ESP32_IP_ADDRESS>'  # Replace with the actual IP address

# Define a global variable to store the LED status
led_status = "off"

@api_view(['GET'])
def led_on_view(request):
    global led_status
    print("Received GET request for LED ON")
    try:
        response = requests.post(f'{ESP32_URL}/led/on')
        if response.status_code == 200:
            led_status = "on"
            return JsonResponse({'status': 'success', 'message': '|OPENEN%'}, status=status.HTTP_200_OK)
        else:
            return JsonResponse({'status': 'Failed to turn on LED'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    except requests.exceptions.RequestException as e:
        return JsonResponse({'status': 'Failed to connect to ESP32'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def led_off_view(request):
    global led_status
    print("Received GET request for LED OFF")
    try:
        response = requests.post(f'{ESP32_URL}/led/off')
        if response.status_code == 200:
            led_status = "off"
            return JsonResponse({'status': 'success', 'message': 'C'}, status=status.HTTP_200_OK)
        else:
            return JsonResponse({'status': 'Failed to turn off LED'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    except requests.exceptions.RequestException as e:
        return JsonResponse({'status': 'Failed to connect to ESP32'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
def led_status_view(request):
    global led_status
    return JsonResponse({'status': led_status}, status=status.HTTP_200_OK)



//urls.py
'''
from django.urls import path
from .views import led_on_view, led_off_view

urlpatterns = [
    path('led/on/', led_on_view, name='led_on_view'),
     path('led/off/', led_off_view, name='led_off_view'),
]
'''
from django.urls import path
from .views import led_on_view, led_off_view, led_status_view

urlpatterns = [
    path('api/led/on/', led_on_view, name='led_on_view'),
    path('api/led/off/', led_off_view, name='led_off_view'),
    path('api/led/status/', led_status_view, name='led_status_view'),
]

//main urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('controlledweb.urls')),
]

//Final Esp32 code which communicates with python django. when i click on the led on button then django will get it and send the json data to esp32. and esp32 control the led
from machine import Pin
import network
import urequests as requests
import time

SSID = 'Redme10'
PASSWORD = 'abcd1234'
LED_PIN = 2  # GPIO 2 for the built-in LED

led = Pin(LED_PIN, Pin.OUT)

def connect_wifi(ssid, password):
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(ssid, password)
    while not wlan.isconnected():
        pass
    print('Network config:', wlan.ifconfig())

def handle_requests():
    while True:
        response = None
        try:
            response = requests.get("http://192.168.178.76:8000/api/led/status/")  # Replace with your Django API endpoint
            if response.status_code == 200:
                data = response.json()
                if data['status'] == 'on':
                    led.on()
                elif data['status'] == 'off':
                    led.off()
        except Exception as e:
            print("Error:", e)
        finally:
            if response:
                response.close()
        time.sleep(1)

# Connect to WiFi
connect_wifi(SSID, PASSWORD)
handle_requests()

# ye humara complete fronted and backened ka code hai ki kaise hum fronted webpage se esp32 ke led ko control kar sakte hai
/*
//ESP32 code. this is the testing code using flask
from machine import Pin
from time import sleep
import network
import urequests as requests
import ujson as json

device_id = "Device0001"
ssid = "Airtel_tejv_3002"
password = "air73137"

HTTPS_GET_URL = "http://192.168.1.24:8000/esp32/boom/"

LED_PIN = 2  # GPIO 2 for the built-in LED

def setup():
    global led
    led = Pin(LED_PIN, Pin.OUT)
    setup_wifi()

def loop():
    response = HTTPS_GET(HTTPS_GET_URL)
    if response and response.get("status") == "success":
        led.on()
        sleep(1)
        led.off()

    sleep(1)

def setup_wifi():
    sta_if = network.WLAN(network.STA_IF)
    if not sta_if.isconnected():
        print('Connecting to network...')
        sta_if.active(True)
        sta_if.connect(ssid, password)
        while not sta_if.isconnected():
            pass
    print('Network config:', sta_if.ifconfig())

def HTTPS_GET(HTTPS_GET_URL):
    print("\nGetting from:", HTTPS_GET_URL)

    print("Connecting to server...")
    try:
        response = requests.get(HTTPS_GET_URL)
        if response.status_code == 200:
            print("ServerResponse:", response.text)
            return response.json()  # Parse and return the JSON response
        else:
            print("Failed to GET. Error:", response.text)
            return None
    except Exception as e:
        print("Exception occurred:", e)
        return None

setup()
while True:
    loop()

// raspberry pi pico w code
import requests
import json
from time import sleep
import RPi.GPIO as GPIO

device_id = "Device0001"
ssid = "Airtel_tejv_3002"
password = "air73137"

HTTPS_GET_URL = "http://192.168.1.24:8000/esp32/boom/"

LED_PIN = 2  # GPIO 2 for the built-in LED

def setup():
    global led
    GPIO.setmode(GPIO.BCM)  # Use Broadcom (BCM) pin numbering
    GPIO.setup(LED_PIN, GPIO.OUT)  # Set pin as output
    setup_wifi()

def loop():
    response = HTTPS_GET(HTTPS_GET_URL)
    if response and response.get("status") == "success":
        GPIO.output(LED_PIN, GPIO.HIGH)  # Turn on LED
        sleep(1)
        GPIO.output(LED_PIN, GPIO.LOW)  # Turn off LED

    sleep(1)

def setup_wifi():
    # Assuming the Raspberry Pi is already connected to Wi-Fi
    print(f'Connected to network {ssid}')

def HTTPS_GET(HTTPS_GET_URL):
    print("\nGetting from:", HTTPS_GET_URL)

    print("Connecting to server...")
    try:
        response = requests.get(HTTPS_GET_URL)
        if response.status_code == 200:
            print("ServerResponse:", response.text)
            return response.json()  # Parse and return the JSON response
        else:
            print("Failed to GET. Error:", response.text)
            return None
    except Exception as e:
        print("Exception occurred:", e)
        return None

setup()
while True:
      loop()

// flask server code for testing the esp32 is working or not

from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/esp32/boom/', methods=['GET'])
def handle_get():
    response = {
        "status": "success",
        "data": "LED should toggle"
    }
    return jsonify(response)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)
*/
