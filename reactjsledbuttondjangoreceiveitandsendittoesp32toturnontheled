Note- in the esp32 i need to use the mysystem ip which is 192.168.178.76:8000 because i am connecting with the wifi network. so to connect with the django python i need to
run it with command python manage.py runserver 192.168.178.76:8000 port. and when i run the react using npm start then it will run on http://192.168.178.76:3000 port. so but in the react js
where i have used axios get there i need to use the djangopython server running ip and port http://192.168.178.76:8000/api/led/off/ so that django will receive the data through this http  . 

for example write now i have not connected with the esp32. so i am not running the my django with the system ip so my django is running on http://localhost:8000 port and my react is running
on http://192.168.178.76:3000 port because i am connecting with the system ip because i am connecting with my wifi network. so i will use the axios.get('http://localhost:8000/api/led/on/') so in axios always remeber we will pass the django server ip and port in which django is running then only it work



// React js code
//Step-1 Components/ Controlled.js
/*
import React from 'react';
import axios from 'axios';
import './Controlled.css';

function Controlled() {
  const handleLedOn = async () => {
    try {
      const response = await axios.post('http://192.168.178.76:8000/api/led/on/'); /* this is my system ip 192.168.178.76:8000 and python django server is running on 0.0.0.0:8000 hum yaha pass wo ip likhenge jisme humara django server run ho rha hai    */
      console.log(response.data);
    } catch (error) {
      console.error("There was an error turning on the LED!", error);
    }
  };

  const handleLedOff = async () => {
    try {
      const response = await axios.post('http://192.168.178.76:8000/api/led/off/'); /* this is my system ip 192.168.178.76:8000 and python django server is running on 0.0.0.0:8000 hum yaha pass wo ip likhenge jisme humara django server run ho rha hai    */
      console.log(response.data);
    } catch (error) {
      console.error("There was an error turning off the LED!", error);
    }
  };

  return (
    <div>
      <h1>ESP32 LED Control</h1>
      <div className="control">
        <button className="btn btn-primary m-2" onClick={handleLedOn}>LED On</button>
        <button className="btn btn-danger m-2" onClick={handleLedOff}>LED Off</button>
      </div>
    </div>
  );
}

export default Controlled;




//Step-2 Components/ Controlled.css

//Step-3 App.js
import './App.css';
import Controlled from './Components/Controlled';
function App() {
  return (
    <div className="App">
      <Controlled/>
    </div>
  );
}

export default App;


//Step-4 App.css
.App {
  text-align: center;
}

// backened/controlled/
views.py
'''
from django.http import JsonResponse
from rest_framework.decorators import api_view
from rest_framework import status
import requests

led_status = "off"

@api_view(['POST'])
def led_on_view(request):
    global led_status
    try:
        led_status = "on"
        return JsonResponse({'status': 'success', 'message': 'LED is turned on'}, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'status': 'Failed to turn on LED', 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
def led_off_view(request):
    global led_status
    try:
        led_status = "off"
        return JsonResponse({'status': 'success', 'message': 'LED is turned off'}, status=status.HTTP_200_OK)
    except Exception as e:
        return JsonResponse({'status': 'Failed to turn off LED', 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['POST'])
def led_status_view(request):
    global led_status
    return JsonResponse({'status': led_status}, status=status.HTTP_200_OK)

//urls.py
from django.urls import path
from .views import led_on_view, led_off_view, led_status_view

urlpatterns = [
    path('api/led/on/', led_on_view, name='led_on'),
    path('api/led/off/', led_off_view, name='led_off'),
    path('api/led/status/', led_status_view, name='led_status'),
]


//main urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('controlledweb.urls')),  # Ensure you include your app's URLs
]


//Final Esp32 code which communicates with python django. when i click on the led on button then django will get it and send the json data to esp32. and esp32 control the led
from machine import Pin
import network
import urequests as requests
import time

SSID = 'Redmi10'
PASSWORD = 'abcd1234'
LED_PIN = 2  # GPIO 2 for the built-in LED

led = Pin(LED_PIN, Pin.OUT)

def connect_wifi(ssid, password):
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(ssid, password)
    while not wlan.isconnected():
        pass
    print('Network config:', wlan.ifconfig())

def handle_requests():
    while True:
        try:
            response = requests.post("http://192.168.178.76:8000/api/led/status/") 
            if response.status_code == 200:
                data = response.json()
                if data['status'] == 'on':
                    led.on()
                elif data['status'] == 'off':
                    led.off()
        except Exception as e:
            print("Error:", e)
        time.sleep(1)

connect_wifi(SSID, PASSWORD)
handle_requests()



# ye humara complete fronted and backened ka code hai ki kaise hum fronted webpage se esp32 ke led ko control kar sakte hai
/*
//ESP32 code. this is the testing code using flask
from machine import Pin
from time import sleep
import network
import urequests as requests
import ujson as json

device_id = "Device0001"
ssid = "Airtel_tejv_3002"
password = "air73137"

HTTPS_GET_URL = "http://192.168.1.24:8000/esp32/boom/"

LED_PIN = 2  # GPIO 2 for the built-in LED

def setup():
    global led
    led = Pin(LED_PIN, Pin.OUT)
    setup_wifi()

def loop():
    response = HTTPS_GET(HTTPS_GET_URL)
    if response and response.get("status") == "success":
        led.on()
        sleep(1)
        led.off()

    sleep(1)

def setup_wifi():
    sta_if = network.WLAN(network.STA_IF)
    if not sta_if.isconnected():
        print('Connecting to network...')
        sta_if.active(True)
        sta_if.connect(ssid, password)
        while not sta_if.isconnected():
            pass
    print('Network config:', sta_if.ifconfig())

def HTTPS_GET(HTTPS_GET_URL):
    print("\nGetting from:", HTTPS_GET_URL)

    print("Connecting to server...")
    try:
        response = requests.get(HTTPS_GET_URL)
        if response.status_code == 200:
            print("ServerResponse:", response.text)
            return response.json()  # Parse and return the JSON response
        else:
            print("Failed to GET. Error:", response.text)
            return None
    except Exception as e:
        print("Exception occurred:", e)
        return None

setup()
while True:
    loop()

// raspberry pi pico w code
import requests
import json
from time import sleep
import RPi.GPIO as GPIO

device_id = "Device0001"
ssid = "Airtel_tejv_3002"
password = "air73137"

HTTPS_GET_URL = "http://192.168.1.24:8000/esp32/boom/"

LED_PIN = 2  # GPIO 2 for the built-in LED

def setup():
    global led
    GPIO.setmode(GPIO.BCM)  # Use Broadcom (BCM) pin numbering
    GPIO.setup(LED_PIN, GPIO.OUT)  # Set pin as output
    setup_wifi()

def loop():
    response = HTTPS_GET(HTTPS_GET_URL)
    if response and response.get("status") == "success":
        GPIO.output(LED_PIN, GPIO.HIGH)  # Turn on LED
        sleep(1)
        GPIO.output(LED_PIN, GPIO.LOW)  # Turn off LED

    sleep(1)

def setup_wifi():
    # Assuming the Raspberry Pi is already connected to Wi-Fi
    print(f'Connected to network {ssid}')

def HTTPS_GET(HTTPS_GET_URL):
    print("\nGetting from:", HTTPS_GET_URL)

    print("Connecting to server...")
    try:
        response = requests.get(HTTPS_GET_URL)
        if response.status_code == 200:
            print("ServerResponse:", response.text)
            return response.json()  # Parse and return the JSON response
        else:
            print("Failed to GET. Error:", response.text)
            return None
    except Exception as e:
        print("Exception occurred:", e)
        return None

setup()
while True:
      loop()

// flask server code for testing the esp32 is working or not

from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/esp32/boom/', methods=['GET'])
def handle_get():
    response = {
        "status": "success",
        "data": "LED should toggle"
    }
    return jsonify(response)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)
*/
